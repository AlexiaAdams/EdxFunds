<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>


  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .state {
      fill: #e3e3e3;
      cursor: pointer;
    }

    .outline {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      fill: none;
      stroke: #777;
    }

    #stickyHead {
      background-color: #ff9971;
      border: 2px solid black;
      padding: 1%;
      position: sticky;
      position: -webkit-sticky;
      top: 0;
    }

    h1 {
      text-align: center;
      background-color: #ffb79b;
      border: 2px solid black;
      padding: 1%;
    }

    .textBlurb {
      background-color: #fca785;
      border: 2px solid black;
      padding: 1%;
      font-size: larger;
    }

    .row,
    .row2 {
      display: flex;
      flex-direction: row;
    }

    .row div {
      width: 50%;
    }

    .row2 div {
      width: 40%;
      margin-left: auto
    }

    .row div h3 {
      text-align: center;
    }

    #stateSelect {
      text-align: center;
      margin: 0;
    }

    ul {
      list-style-type: none;
    }

    .options {
      display: flex;
      flex-direction: row;
    }

    .options li {
      width: 25%;
      text-align: center;
      cursor: pointer;
      border: 2px solid black;
    }

    .selectedOption {
      border: 2px solid black;
      background-color: white;
    }

    .graph-row svg {
      display: block;
      margin: auto;
    }

    #dc,
    #dcText {
      cursor: pointer;
    }

    .details {
      /* width: 10%; */
      background-color: #fca785;
      border: 2px solid black;
      padding: 1%;
      font-size: larger;
    }
  </style>

</head>

<body>

  <h1>Does More Money Mean Better Academic Performance?</h1>

  <p class="textBlurb">
    <strong>Education is the foundation for societal growth and innovation.</strong> Each state sets their own standards
    for education. We wanted to investgate the relationship between academic performance in public elementary and
    secondary schools and the current spending and revenue (broken up by government level) per pupil.

    <br>
    <br>

    <em>Select up to 5 states from the map.</em>
  </p>

  <div id="stickyHead">

    <div class="row">
      <div>
        <h3>Finances</h3>

        <ul class="options">
          <li id="opPPCS" class="selectedOption">Current Spending</li>
          <li id="opFed">Federal Revenue</li>
          <li id="opState">State Revenue</li>
          <li id="opLocal">Local Revenue</li>
        </ul>

      </div>

      <div>
        <h3>Performance</h3>

        <ul class="options">
          <li id="opG4">NAEP Grade 4</li>
          <li id="opG8">NAEP Grade 8</li>
          <li id="opSAT" class="selectedOption">SAT</li>
          <li id="opACT">ACT</li>
        </ul>

      </div>
    </div>

    <h4 id="stateSelect">States Selected: None</h4>

  </div>

  <div class="row graph-row">
    <svg id="map1" width="750" height="750"></svg>
    <svg id="spending" height="600" width="600"></svg>
  </div>
  <div class="row graph-row">
    <svg id="math" width="500" height="500"></svg>
    <svg id="read" width="500" height="500"></svg>
  </div>

  <br>

  <div class="row2">
    <svg id="scatter" width="500" height="500"></svg>
    <svg id="scatterLegend" width="200" height="400"></svg>

    <div class="details">
      <p><strong>SAT</strong>: The total SAT score ranges from 400 to 1600.</p>
      <p><strong>ACT</strong>: The total ACT score ranges from 1 to 36.</p>
      <p><strong>NAEP</strong>: The total NAEP score ranges from 0 to 500.</p>

      <p>States with low participation rates for SAT and ACT tests perform better than states that have almost full
        participation; this may be because of students wanting to be competitive in the college application process by
        taking a locally "unpopular" standardized test.</p>
      <br>
      <br>
      <!-- <p>
        Overall, it is difficult to see if more money correlates to better performance on this scale; we don't know
        <em>how</em> each state spends their money.
      </p> -->
    </div>
  </div>



  <p>
    The SAT ranges from 400 to 1600. The ACT ranges from 1 to 36. The NAEP ranges from 0 to 500.
  </p>

  <script>
    // Map of spending
    const svg = d3.select("#map1");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const mapChart = svg.append("g")
      .attr("id", "mapChart")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Bar chart of spending
    const svgSpend = d3.select("#spending");
    const wSpend = svgSpend.attr("width");
    const hSpend = svgSpend.attr("height");
    const marginSpend = { top: 10, right: 10, bottom: 50, left: 50 };
    const spendChartW = wSpend - marginSpend.left - marginSpend.right;
    const spendChartH = hSpend - marginSpend.bottom - marginSpend.top;
    const spendChart = svgSpend.append("g")
      .attr("id", "spendChart")
      .attr("transform", `translate(${marginSpend.left},${marginSpend.top})`);

    // Bar chart of math performance
    const svgMath = d3.select("#math");
    const wMath = svgMath.attr("width");
    const hMath = svgMath.attr("height");
    const marginMath = { top: 10, right: 10, bottom: 50, left: 50 };
    const mathChartW = wMath - marginMath.left - marginMath.right;
    const mathChartH = hMath - marginMath.bottom - marginMath.top;
    const mathChart = svgMath.append("g")
      .attr("id", "mathChart")
      .attr("transform", `translate(${marginMath.left},${marginMath.top})`);

    // Bar chart of english/reading performance
    const svgRead = d3.select("#read");
    const wRead = svgRead.attr("width");
    const hRead = svgRead.attr("height");
    const marginRead = { top: 10, right: 10, bottom: 50, left: 50 };
    const readChartW = wRead - marginRead.left - marginRead.right;
    const readChartH = hRead - marginRead.bottom - marginRead.top;
    const readChart = svgRead.append("g")
      .attr("id", "mathChart")
      .attr("transform", `translate(${marginRead.left},${marginRead.top})`);

    // Scatter plot
    const svgScatter = d3.select("#scatter")
    const wScatter = svgScatter.attr("width")
    const hScatter = svgScatter.attr("height")
    const marginScatter = { top: 10, right: 10, bottom: 50, left: 50 }
    const scatterChartW = wScatter - marginScatter.left - marginScatter.right
    const scatterChartH = hScatter - marginScatter.top - marginScatter.bottom
    const scatterChart = svgScatter.append("g")
      .attr("id", "scatterChart")
      .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`);

    // Legend for scatter plot
    const svgLeg = d3.select("#scatterLegend");
    const legW = svgLeg.attr("width");
    const legH = svgLeg.attr("height");

    const requestData = async function () {

      // ------------ Setting up US Map ------------
      const us = await d3.json("us-smaller.json");
      console.log(us);

      var states = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([chartWidth, chartHeight], states);
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();
      mapChart.append("path").attr("class", "graticule").attr("d", path(graticule))

      mapChart.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState)
        .on("click", mouseChangeState)

      mapChart.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      let dcButton = mapChart.append("g")
        .attr("class", "dc")

      dcButton.append("circle")
        .style("stroke", "black")
        .style("stroke-width", 2)
        .attr("cx", chartWidth - 2 * (margin.left + margin.right))
        .attr("cy", chartHeight - 400)
        .attr("r", 20)
        .attr("id", "dc")
        .on("mouseover", dcMouseOver)
        .on("mouseout", dcMouseOut)
        .on("click", dcMouseChange)

      dcButton.append("text")
        .text("DC")
        .attr("x", chartWidth - 2 * (margin.left + margin.right))
        .attr("y", chartHeight - 400 - 5)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .style("fill", "white")
        .attr("id", "dcText")
        .on("mouseover", dcMouseOver)
        .on("mouseout", dcMouseOut)
        .on("click", dcMouseChange)

      // ------------ Per Pupil Spending by State ------------
      // Can't use d3.autotype because it causes errors with the rev vars
      const edSpend = await d3.csv("es_spend_2022.csv");

      // Fixing data types
      edSpend.forEach((d) => {
        let strToInt = ["ppcs", "pp_rev_total", "pp_rev_fed",
          "pp_rev_state", "pp_rev_local"]

        for (let i = 0; i < strToInt.length; i++) {
          d[strToInt[i]] = parseInt(d[strToInt[i]].replace(",", ""));
        }

        let numerics = ["sat_total", "sat_erw", "sat_math", "sat_perc",
          "act_total", "act_math", "act_read", "act_eng", "act_sci", "act_perc",
          "g8_read", "g8_math", "g4_read", "g4_math"]

        for (let i = 0; i < numerics.length; i++) {
          d[numerics[i]] = Number(d[numerics[i]])
        }

        d["act_erw"] = (d["act_eng"] + d["act_read"]) / 2
      })
      console.log(edSpend)

      // Maps state ID (from map) to the state code
      let stateIDcode = {}

      // Maps state name to state code (used for bar graph)
      let stateNameCode = {}

      // Maps state code to index in edSpend (used for bar graph)
      let codeToEdID = {}

      for (let i = 0; i <= 51; i++) {
        // Alphabetically ordered
        stateIDcode[us.objects.states.geometries[i].id] = edSpend[i].code
        us.objects.states.geometries[i].properties = edSpend[i]

        stateNameCode[edSpend[i].state] = edSpend[i].code
        codeToEdID[edSpend[i].code] = i
      }

      let ppcs = {}
      let fedRev = {}
      let stateRev = {}
      let localRev = {}
      let stateNames = {}
      let satPercs = {}
      let actPercs = {}

      edSpend.forEach(d => {
        ppcs[d.code] = d.ppcs;
        fedRev[d.code] = d["pp_rev_fed"];
        stateRev[d.code] = d["pp_rev_state"];
        localRev[d.code] = d["pp_rev_local"];
        stateNames[d.code] = d.state;

        satPercs[d.code] = d["sat_perc"]
        actPercs[d.code] = d["act_perc"]
      });

      // Highlighting states on click
      let selectedStates = []

      // color options
      let greenColors = ["#cce7c9", "#8bca84", "#5bb450", "#46923c", "#276221"]
      let purpleColors = ["#bca0dc", "#b491c8", "#7c5295", "#663a82", "#52307c"]
      let cyanColors = ["#45f7e5", "#3bd1c2", "#33b3a6", "#289086", "#207169"]
      let blueColors = ["#caf0f8", "#90e0ef", "#00b4d8", "#0077b6", "#023e8a"]
      let pinkColors = ["#eec4dc", "#e27bb1", "#e44b8d", "#bb437e", "#7f3667"]
      let coolColors = ["#3acadf", "#729efd", "#8a64d6", "#5c3a92"]
      let warmColors = ["#ffc100", "#ff9800", "#ff5607", "#f6412d"]

      let useColors = greenColors

      let perfVarMath = "sat_math"
      let perfVarRead = "sat_erw"

      function updateMap(spendVar, spendDct) {
        // default => ppcs
        let useColors = greenColors

        if (spendVar == "pp_rev_fed") {
          useColors = purpleColors
        }
        if (spendVar == "pp_rev_state") {
          useColors = cyanColors
        }
        if (spendVar == "pp_rev_local") {
          useColors = blueColors
        }

        const spendExtent = d3.extent(Object.values(spendDct));

        const spendColorScale = d3.scaleQuantile()
          .domain(Object.values(spendDct))
          .range(useColors);

        mapChart.selectAll(".state")
          .data(edSpend)
          .style("fill", d => spendColorScale(spendDct[d.code]))

        let borderColor = "yellow"
        let borderSize = 3
        if (selectedStates.indexOf("District of Columbia") === -1) {
          borderColor = "black"
          borderSize = 2
        }

        dcButton.select("circle")
          .attr("fill", spendColorScale(spendDct["DC"]))
          .attr("stroke", borderColor)
          .attr("stroke-width", borderSize)

        // Create color scale legend
        let legendQuantile = mapChart.append("g")
          .attr("class", "legend")

        let scaleW = 50

        for (let i = 0; i < useColors.length; i++) {
          legendQuantile.append("rect")
            .attr("fill", useColors[i])
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .attr("x", chartWidth / 4 + (i * scaleW))
            .attr("y", chartHeight - 100)
            .attr("width", scaleW)
            .attr("height", 25)
        }

        let testExt = [spendExtent[0], spendColorScale.quantiles()[0],
        spendColorScale.quantiles()[1], spendColorScale.quantiles()[2],
        spendColorScale.quantiles()[3], spendExtent[1]]

        const colorLegendScale = d3.scaleOrdinal()
          .domain(testExt)
          .range([0, scaleW, scaleW * 2, scaleW * 3, scaleW * 4, scaleW * 5])

        let bottomAxisColor = d3.axisBottom(colorLegendScale)
          .ticks(4)
          .tickValues(testExt)
          .tickFormat(d3.format("$.2s"))

        legendQuantile.append("g")
          .attr("class", "x axis legRemove")
          .attr("transform",
            `translate(${chartWidth / 4},${chartHeight - 75})`
          )
          .call(bottomAxisColor);

        return [spendExtent, spendColorScale, spendVar]
      }

      let spendValues = updateMap("ppcs", ppcs)
      let spendExtent = spendValues[0]
      let spendColorScale = spendValues[1]
      let spendVar = spendValues[2]

      // Tool Tip
      let toolTipWidth = 200
      let toolTipHeight = 75

      let mouseMesh = mapChart.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "orange")
        .style("stroke-width", 1)
        .attr("d", "")

      let clickMesh = mapChart.append("path")
        .attr("class", "click outline")
        .style("stroke", "yellow")
        .style("stroke-width", 3)
        .attr("d", "")

      let toolTip = mapChart.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      let xPos = width - (toolTipWidth * 1.5) - margin.left - margin.right
      let yPos = toolTipHeight + margin.top

      toolTip.append("rect")
        .attr("fill", "black")
        .attr("opacity", .8)
        .attr("rx", 6)
        .attr("ry", 6)
        .attr("x", xPos)
        .attr("y", yPos)
        .attr("width", toolTipWidth)
        .attr("height", toolTipHeight);

      let stateText = toolTip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", xPos + (toolTipWidth / 2))
        .attr("y", yPos + 5);

      let ppcsText = toolTip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", xPos + (toolTipWidth / 2))
        .attr("y", yPos + 25);

      // DC Mouseover
      function dcMouseOver() {
        toolTip.style("visibility", "visible");
        let dc = d3.select("#dc")
        var format = d3.format("$,")
        stateText.text("District of Columbia (DC)")
        ppcsText.text(format(edSpend[8][spendVar]))

        var mou = topojson.mesh(us, us.objects.states, function (a, b) {
          return a.id < 72 && a.properties.state === "District of Columbia"
            || b.id < 72 && b.properties.state === "District of Columbia"
        });

        mouseMesh.datum(mou).attr("d", path)

        if (selectedStates.indexOf("District of Columbia") === -1) {
          dc.style("stroke", "orange")
        }
      }

      function dcMouseOut() {
        toolTip.style("visibility", "hidden");
        let dc = d3.select("#dc")
        if (selectedStates.indexOf("District of Columbia") === -1) {
          dc.style("stroke", "black")
        }
        mouseMesh.attr("d", "")
      }

      function dcMouseChange() {
        let dc = d3.select("#dc")
        if (selectedStates.length < 5 && selectedStates.indexOf("District of Columbia") === -1) {
          selectedStates.push("District of Columbia");
          console.log("Turn Yellow")
          highlightState(selectedStates);
          dc.style("stroke", "yellow")
            .style("stroke-width", 3)
        } else {
          if (selectedStates.length == 5 && selectedStates.indexOf("District of Columbia") === -1) {
            console.log("Too many states selected. Click a selected state to remove.")
          } else {
            console.log("Turn Orange")
            selectedStates.splice(selectedStates.indexOf("District of Columbia"), 1)
            highlightState(selectedStates);
            dc.style("stroke", "orange")
              .style("stroke-width", 2)
          }
        }
        updateStateList()

        d3.selectAll("g.remove").remove()
        d3.selectAll("text.remove").remove()
        updateGraph(selectedStates, spendExtent)

        d3.selectAll("g.removePerf").remove()
        d3.selectAll("text.removePerf").remove()
        updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

      }

      // Mouse In
      function mouseEntersState() {
        toolTip.style("visibility", "visible");

        let st = d3.select(this);

        var format = d3.format("$,")

        stateText.text(st.datum().state + " (" + st.datum().code + ")")
        ppcsText.text(format(st.datum()[spendVar]))

        var mou = topojson.mesh(us, us.objects.states, function (a, b) {
          return a.id < 72 && a.properties.state === st.datum().state || b.id < 72 && b.properties.state === st.datum().state
        });

        mouseMesh.datum(mou).attr("d", path)
      }

      // Mouse Out
      function mouseLeavesState() {
        toolTip.style("visibility", "hidden");

        let st = d3.select(this)

        mouseMesh.attr("d", "")
      }

      function highlightState(selectedStates) {
        let len = selectedStates.length

        if (len === 1) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
          });
        }
        if (len === 2) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
          });
        }
        if (len === 3) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]

          });
        }
        if (len === 4) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]
              || a.id < 72 && a.properties.state === selectedStates[3] || b.id < 72 && b.properties.state === selectedStates[3]

          });
        }
        if (len === 5) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]
              || a.id < 72 && a.properties.state === selectedStates[3] || b.id < 72 && b.properties.state === selectedStates[3]
              || a.id < 72 && a.properties.state === selectedStates[4] || b.id < 72 && b.properties.state === selectedStates[4]
          });
        }

        clickMesh.datum(mou).attr("d", path)
      }

      // Mouse Change
      function mouseChangeState() {
        let st = d3.select(this);

        if (selectedStates.length < 5 && selectedStates.indexOf(st.datum().state) === -1) {
          selectedStates.push(st.datum().state);
          highlightState(selectedStates);
        } else {
          if (selectedStates.length == 5 && selectedStates.indexOf(st.datum().state) === -1) {
            console.log("Too many states selected. Click a selected state to remove.")
          } else {
            selectedStates.splice(selectedStates.indexOf(st.datum().state), 1)
            highlightState(selectedStates);
          }
        }

        updateStateList()

        d3.selectAll("g.remove").remove()
        d3.selectAll("text.remove").remove()
        updateGraph(selectedStates, spendExtent)

        d3.selectAll("g.removePerf").remove()
        d3.selectAll("text.removePerf").remove()
        updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)
      }

      function updateStateList() {
        const ssHeader = d3.select("#stateSelect");
        if (selectedStates.length == 0) {
          ssHeader.text("States Selected: None")
        } else {
          let acc_str = "States Selected: "
          for (let i = 0; i < selectedStates.length; i++) [
            acc_str = acc_str + selectedStates[i] + ", "
          ]
          acc_str = acc_str.substring(0, acc_str.length - 2)
          ssHeader.text(acc_str)
        }
      }

      // ------------ All Bar Charts  ------------

      // ------------ Spending Bar Chart ------------

      let spendAnno = svgSpend.append("g").attr("id", "spendAnno");
      let mathAnno = svgMath.append("g").attr("id", "mathAnno");
      let readAnno = svgRead.append("g").attr("id", "readAnno");

      // update spending bar graph depended on states selected
      function updateGraph(selectedStates, spendExtent) {
        // x axis = selected states + us
        let barStates = []
        barStates.push("US")

        // Change state names to state codes
        for (let i = 0; i < selectedStates.length; i++) {
          barStates.push(stateNameCode[selectedStates[i]]);
        }

        let barIDs = []

        for (let i = 0; i < barStates.length; i++) {
          barIDs.push(codeToEdID[barStates[i]])
        }

        let subData = edSpend.filter((d, i) => {
          return barIDs.includes(i)
        });

        let xStateScale = d3.scaleBand()
          .domain(barStates)
          .range([0, wSpend - marginSpend.left]);

        let bottomAxisSpend = d3.axisBottom(xStateScale);

        let ySpendScale = d3.scaleLinear()
          .domain([0, spendExtent[1]])
          .range([spendChartH, 0])

        let leftAxisSpend = d3.axisLeft(ySpendScale).tickFormat(d3.format("$.2s"));

        spendAnno.append("g")
          .attr("class", "y axis remove")
          .attr("transform",
            `translate(${marginSpend.left},${marginSpend.top})`
          )
          .call(leftAxisSpend);

        let leftGridlinesSpend = d3.axisLeft(ySpendScale)
          .tickSize(-wSpend - marginSpend.right)
          .tickFormat("");

        spendAnno.append("g")
          .attr("class", "y gridlines remove")
          .attr("transform",
            `translate(${marginSpend.left},${marginSpend.top})`
          )
          .call(leftGridlinesSpend);

        spendAnno.append("g")
          .attr("class", "x axis remove")
          .attr("transform",
            `translate(${marginSpend.left},${hSpend - marginSpend.bottom})`
          )
          .call(bottomAxisSpend);

        spendAnno.append("text")
          .attr("class", "x-label remove")
          .attr("transform", `translate(${spendChartW / 2 + marginSpend.left}, ${hSpend - marginSpend.bottom + 4 * marginSpend.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let spendYLabel = "Current Spending Per Pupil"

        if (spendVar == "pp_rev_fed") {
          spendYLabel = "Federal Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_state") {
          spendYLabel = "State Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_local") {
          spendYLabel = "Local Revenue Per Pupil"
        }

        spendAnno.append("text")
          .attr("class", "y-label remove")
          .attr("transform", `translate(${marginSpend.right}, ${spendChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(spendYLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        spendAnno.append("text")
          .attr("class", "chart-title remove")
          .attr("transform", `translate(${spendChartH / 2 + marginSpend.left}, ${marginSpend.top})`)
          .style("text-anchor", "middle")
          .text(spendYLabel + " for Elementary-Secondary (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let barW = 20

        spendChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => ySpendScale(d[spendVar]))
          .attr("height", d => spendChartH - ySpendScale(d[spendVar]))
          .attr("width", d => barW)

        let noData = subData.filter((d) => {
          return d[spendVar] == 0
        });

        spendChart.append("text")
          .data(noData)
          .text("N/A")
          .attr("class", "no-data remove")
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", spendChartH / 2)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        spendChart.raise()
      }

      function updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead) {
        let barStates = []
        barStates.push("US")

        // Change state names to state codes
        for (let i = 0; i < selectedStates.length; i++) {
          barStates.push(stateNameCode[selectedStates[i]]);
        }

        let barIDs = []

        for (let i = 0; i < barStates.length; i++) {
          barIDs.push(codeToEdID[barStates[i]])
        }

        let subData = edSpend.filter((d, i) => {
          return barIDs.includes(i)
        });

        let xStateScale = d3.scaleBand()
          .domain(barStates)
          .range([0, wMath - marginMath.left]);

        // default: sat
        let perfExtent = [200, 800]
        let yMathLabel = "SAT Math Scores"
        let yReadLabel = "SAT ERW Scores"

        if (perfVarMath == "act_math") {
          perfExtent = [2, 36]
          yMathLabel = "ACT Math Scores"
          yReadLabel = "ACT Reading + English Scores"
        }
        if (perfVarMath == "g4_math") {
          perfExtent = [0, 500]
          yMathLabel = "NAEP Grade 4 Math Scores"
          yReadLabel = "NAEP Grade 4 Reading Scores"
        }
        if (perfVarMath == "g8_math") {
          perfExtent = [0, 500]
          yMathLabel = "NAEP Grade 8 Math Scores"
          yReadLabel = "NAEP Grade 8 Reading Scores"
        }

        let yMathScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([mathChartH, 0])

        let leftAxisMath = d3.axisLeft(yMathScale)

        mathAnno.append("g")
          .attr("class", "y axis removePerf")
          .attr("transform",
            `translate(${marginMath.left},${marginMath.top})`
          )
          .call(leftAxisMath);

        let leftGridlinesMath = d3.axisLeft(yMathScale)
          .tickSize(-mathChartW - marginMath.right)
          .tickFormat("");

        mathAnno.append("g")
          .attr("class", "y gridlines removePerf")
          .attr("transform",
            `translate(${marginMath.left},${marginMath.top})`
          )
          .call(leftGridlinesMath);

        let bottomAxisMath = d3.axisBottom(xStateScale);

        mathAnno.append("g")
          .attr("class", "x axis removePerf")
          .attr("transform",
            `translate(${marginMath.left},${mathChartH + marginMath.top})`
          )
          .call(bottomAxisMath);

        mathAnno.append("text")
          .attr("class", "x-label removePerf")
          .attr("transform", `translate(${mathChartW / 2 + marginMath.left}, ${hMath - marginMath.bottom + 4 * marginMath.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        mathAnno.append("text")
          .attr("class", "y-label removePerf")
          .attr("transform", `translate(${marginMath.right}, ${mathChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yMathLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        mathAnno.append("text")
          .attr("class", "chart-title removePerf")
          .attr("transform", `translate(${mathChartH / 2 + marginMath.left}, ${marginMath.top})`)
          .style("text-anchor", "middle")
          .text("Average " + yMathLabel + " (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let barW = 20

        mathChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => yMathScale(d[perfVarMath]))
          .attr("height", d => mathChartH - yMathScale(d[perfVarMath]))
          .attr("width", d => barW)

        let noDataMath = subData.filter((d) => {
          return d[perfVarMath] == 0
        });

        mathChart.selectAll("text")
          .data(noDataMath)
          .join("text")
          .text("N/A")
          .attr("class", "no-data removePerf")
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", mathChartH / 2)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        mathChart.raise()

        // ---- Reading ----
        let yReadScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([readChartH, 0])

        let leftAxisRead = d3.axisLeft(yReadScale);

        readAnno.append("g")
          .attr("class", "y axis removePerf")
          .attr("transform",
            `translate(${marginRead.left},${marginRead.top})`
          )
          .call(leftAxisRead);

        let leftGridlinesRead = d3.axisLeft(yReadScale)
          .tickSize(-readChartW - marginRead.right)
          .tickFormat("");

        readAnno.append("g")
          .attr("class", "y gridlines removePerf")
          .attr("transform",
            `translate(${marginRead.left},${marginRead.top})`
          )
          .call(leftGridlinesRead);

        let bottomAxisRead = d3.axisBottom(xStateScale);

        readAnno.append("g")
          .attr("class", "x axis removePerf")
          .attr("transform",
            `translate(${marginRead.left},${readChartH + marginRead.top})`
          )
          .call(bottomAxisRead);

        readAnno.append("text")
          .attr("class", "x-label removePerf")
          .attr("transform", `translate(${readChartW / 2 + marginRead.left}, ${hRead - marginRead.bottom + 4 * marginRead.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readAnno.append("text")
          .attr("class", "y-label removePerf")
          .attr("transform", `translate(${marginRead.right}, ${readChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yReadLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readAnno.append("text")
          .attr("class", "chart-title removePerf")
          .attr("transform", `translate(${readChartH / 2 + marginRead.left}, ${marginRead.top})`)
          .style("text-anchor", "middle")
          .text("Average " + yReadLabel + " (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => yReadScale(d[perfVarRead]))
          .attr("height", d => readChartH - yReadScale(d[perfVarRead]))
          .attr("width", d => barW)

        let noDataRead = subData.filter((d) => {
          return d[perfVarRead] == 0
        });

        readChart.selectAll("text")
          .data(noDataRead)
          .join("text")
          .text("N/A")
          .attr("class", "no-data removePerf")
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", readChartH / 2)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readChart.raise()
      }

      let scatterAnno = svgScatter.append("g").attr("id", "scatterAnno");

      function updateScatter(spendExtent, perfVarMath, perfVarRead) {

        console.log("Scatter Debugging")

        let xSpendScale = d3.scaleLinear()
          .domain(spendExtent)
          .range([0, scatterChartW])

        let perfExtent = [800, 1300]
        let yScatterLabel = "SAT Total Scores"
        let yCol = "sat_total"
        let gradeTest = perfVarMath == "g4_math" || perfVarMath == "g8_math"
        let colorCol = "sat_perc"


        if (perfVarMath == "act_math") {
          perfExtent = [15, 30]
          yScatterLabel = "ACT Composite Scores"
          yCol = "act_total"
          colorCol = "act_perc"
        }
        if (perfVarMath == "g4_math") {
          perfExtent = [175, 325]
          yScatterLabel = "NAEP Grade 4 Scores"
        }
        if (perfVarMath == "g8_math") {
          perfExtent = [175, 325]
          yScatterLabel = "NAEP Grade 8 Scores"
        }

        let colorPercScale = d3.scaleQuantile()
          .domain([0, 100])
          .range(pinkColors);

        let yPerfScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([scatterChartH, 0])

        let leftAxisScatter = d3.axisLeft(yPerfScale).tickFormat(d3.format("d"))

        scatterAnno.append("g")
          .attr("class", "y axis removeScatter")
          .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`)
          .call(leftAxisScatter)

        let leftGridlinesScatter = d3.axisLeft(yPerfScale)
          .tickSize(-scatterChartW - marginScatter.right)
          .tickFormat("")

        scatterAnno.append("g")
          .attr("class", "y gridlines removeScatter")
          .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`)
          .call(leftGridlinesScatter)

        let bottomAxisScatter = d3.axisBottom(xSpendScale).tickFormat(d3.format("$.2s")).ticks(8);

        scatterAnno.append("g")
          .attr("class", "x axis removeScatter")
          .attr("transform", `translate(${marginScatter.left + marginScatter.right / 2},${scatterChartH + marginScatter.top})`)
          .call(bottomAxisScatter)

        let xSpendLabel = "Per Pupil Current Spending"

        if (spendVar == "pp_rev_fed") {
          xSpendLabel = "Federal Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_state") {
          xSpendLabel = "State Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_local") {
          xSpendLabel = "Local Revenue Per Pupil"
        }

        scatterAnno.append("text")
          .attr("class", "x-label removeScatter")
          .attr("transform",
            `translate(${scatterChartW / 2 + marginScatter.left}, ${hScatter - marginScatter.bottom + 4 * marginScatter.top})`
          )
          .style("text-anchor", "middle")
          .text(xSpendLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        scatterAnno.append("text")
          .attr("class", "y-label removeScatter")
          .attr("transform", `translate(${marginScatter.right}, ${scatterChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yScatterLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let legendScatter = svgLeg.append("g")
          .attr("class", "legend removeScatter")

        let scatterLegendScale = d3.scaleOrdinal()
          .domain([0, 20, 40, 60, 80, 100])
          .range([0, 25, 50, 75, 100, 125])

        if (!gradeTest) {
          d3.selectAll("circle.p2").remove()

          scatterChart.selectAll("circle.point")
            .data(edSpend)
            .join("circle")
            .attr("class", "point")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[yCol]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => {
              if (gradeTest) { return "blue" }
              else { return colorPercScale(d[colorCol]) }
            })

          for (let i = 0; i < pinkColors.length; i++) {
            legendScatter.append("rect")
              .attr("fill", pinkColors[i])
              .attr("stroke", "black")
              .attr("stroke-width", 2)
              .attr("x", legW / 2)
              .attr("y", legH / 2 + (i * 25))
              .attr("width", 25)
              .attr("height", 25)
              .attr("class", "removeScatter")
          }

          let rightAxisScatter = d3.axisRight(scatterLegendScale)

          legendScatter.append("g")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2 + 25},${legH / 2})`)
            .call(rightAxisScatter)

          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2}, ${legH / 2 - 25})`)
            .style("text-anchor", "middle")
            .text("Participation Rate (%)")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");

        } else {
          let mathData = edSpend.filter((d) => {
            return d[perfVarMath] > 0
          });

          let readData = edSpend.filter((d) => {
            return d[perfVarRead] > 0
          });

          scatterChart.selectAll("circle.point")
            .data(mathData)
            .join("circle")
            .attr("class", "point")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[perfVarMath]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => NAEPColor(d[perfVarMath], perfVarMath))

          scatterChart.selectAll("circle.p2")
            .data(readData)
            .join("circle")
            .attr("class", "p2")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[perfVarRead]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => NAEPColor(d[perfVarRead], perfVarRead))


          for (let i = 0; i < coolColors.length; i++) {
            // cool read
            legendScatter.append("rect")
              .attr("fill", coolColors[coolColors.length - i - 1])
              .attr("stroke", "black")
              .attr("stroke-width", 2)
              .attr("x", legW / 4 - 25)
              .attr("y", legH / 2 + (i * 25))
              .attr("width", 25)
              .attr("height", 25)
              .attr("class", "removeScatter")

            // warm math
            legendScatter.append("rect")
              .attr("fill", warmColors[coolColors.length - i - 1])
              .attr("stroke", "black")
              .attr("stroke-width", 2)
              .attr("x", legW / 4)
              .attr("y", legH / 2 + (i * 25))
              .attr("width", 25)
              .attr("height", 25)
              .attr("class", "removeScatter")
          }

          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2}, ${legH / 2 - 50})`)
            .style("text-anchor", "middle")
            .text("NAEP Achievement Levels")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");

          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2}, ${legH / 2 - 25})`)
            .style("text-anchor", "middle")
            .text("Read/Math")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");

          // legend labels
          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2 + 25}, ${legH / 2 + 15})`)
            .style("text-anchor", "middle")
            .text("Advanced")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");
          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2 + 25}, ${legH / 2 + 40})`)
            .style("text-anchor", "middle")
            .text("Proficient")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");
          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2 + 25}, ${legH / 2 + 65})`)
            .style("text-anchor", "middle")
            .text("Basic")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");
          legendScatter.append("text")
            .attr("class", "removeScatter")
            .attr("transform", `translate(${legW / 2 + 25}, ${legH / 2 + 90})`)
            .style("text-anchor", "middle")
            .text("Below Basic")
            .attr("fill", "black")
            .style("font-family", "monospace")
            .style("font-weight", "bold");
        }

        scatterChart.raise()
      }

      function NAEPColor(totalScore, perfVar) {
        // this categorization comes from NAEP
        if (perfVar == "g4_math") {
          // Below Basic
          if (totalScore < 214) {
            return warmColors[0]
          }
          // Basic
          if (totalScore >= 214 && totalScore < 249) {
            return warmColors[1]
          }
          // Proficient
          if (totalScore >= 249 && totalScore < 282) {
            return warmColors[2]
          }
          // Advanced
          if (totalScore >= 282) {
            return warmColors[3]
          }
        }
        if (perfVar == "g4_read") {
          if (totalScore < 208) {
            return coolColors[0]
          }
          if (totalScore >= 208 && totalScore < 238) {
            return coolColors[1]
          }
          if (totalScore >= 238 && totalScore < 268) {
            return coolColors[2]
          }
          if (totalScore >= 268) {
            return coolColors[3]
          }
        }
        if (perfVar == "g8_math") {
          if (totalScore < 262) {
            return warmColors[0]
          }
          if (totalScore >= 262 && totalScore < 299) {
            return warmColors[1]
          }
          if (totalScore >= 299 && totalScore < 333) {
            return warmColors[2]
          }
          if (totalScore >= 333) {
            return warmColors[3]
          }
        }
        if (perfVar == "g8_read") {
          if (totalScore < 243) {
            return coolColors[0]
          }
          if (totalScore >= 243 && totalScore < 281) {
            return coolColors[1]
          }
          if (totalScore >= 281 && totalScore < 323) {
            return coolColors[2]
          }
          if (totalScore >= 323) {
            return coolColors[3]
          }
        }
      }

      let toolTipScatter = scatterChart.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      toolTipScatter.append("rect")
        .attr("fill", "black")
        .attr("opacity", .8)
        .attr("rx", 6)
        .attr("ry", 6)
        .attr("x", scatterChartW - marginScatter.left * 3)
        .attr("y", scatterChartH / 2 + marginScatter.bottom * 2)
        .attr("width", 150)
        .attr("height", 75);

      let stText = toolTipScatter.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", scatterChartW - marginScatter.left * 2 + 25)
        .attr("y", scatterChartH / 2 + marginScatter.bottom * 2 + 5)

      let scoreText = toolTipScatter.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", scatterChartW - marginScatter.left * 2 + 25)
        .attr("y", scatterChartH / 2 + marginScatter.bottom * 2 + 25)

      let perfText = toolTipScatter.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", scatterChartW - marginScatter.left * 2 + 25)
        .attr("y", scatterChartH / 2 + marginScatter.bottom * 2 + 45)

      function circleMouseOver() {
        toolTipScatter.style("visibility", "visible");

        let st = d3.select(this);

        st.attr("stroke", "black")
          .attr("stroke-width", 2);

        stText.text(st.datum().state)

        perfText.text("")

        if (satButton.classed("selectedOption")) {
          scoreText.text("Participation: " + st.datum()["sat_perc"] + "%")
        }

        if (actButton.classed("selectedOption")) {
          scoreText.text("Participation: " + st.datum()["act_perc"] + "%")
        }

        if (g4Button.classed("selectedOption")) {
          // math
          if (st.classed("point")) {
            let c = NAEPColor(st.datum()["g4_math"], "g4_math")
            if (c == "#ffc100") {
              scoreText.text("Below NAEP Basic")
            }
            if (c == "#ff9800") {
              scoreText.text("NAEP Basic")
            }
            if (c == "#ff5607") {
              scoreText.text("NAEP Proficient")
            }
            if (c == "#f6412d") {
              scoreText.text("NAEP Advanced")
            }
            perfText.text("Math")
          }
          // reading
          if (st.classed("p2")) {
            let c = NAEPColor(st.datum()["g4_read"], "g4_read")
            if (c == "#3acadf") {
              scoreText.text("Below NAEP Basic")
            }
            if (c == "#729efd") {
              scoreText.text("NAEP Basic")
            }
            if (c == "#8a64d6") {
              scoreText.text("NAEP Proficient")
            }
            if (c == "#5c3a92") {
              scoreText.text("NAEP Advanced")
            }
            perfText.text("Reading")
          }
        }

        if (g8Button.classed("selectedOption")) {
          // math
          if (st.classed("point")) {
            let c = NAEPColor(st.datum()["g8_math"], "g8_math")
            if (c == "#ffc100") {
              scoreText.text("Below NAEP Basic")
            }
            if (c == "#ff9800") {
              scoreText.text("NAEP Basic")
            }
            if (c == "#ff5607") {
              scoreText.text("NAEP Proficient")
            }
            if (c == "#f6412d") {
              scoreText.text("NAEP Advanced")
            }
            perfText.text("Math")
          }
          // reading
          if (st.classed("p2")) {
            let c = NAEPColor(st.datum()["g8_read"], "g8_read")
            if (c == "#3acadf") {
              scoreText.text("Below NAEP Basic")
            }
            if (c == "#729efd") {
              scoreText.text("NAEP Basic")
            }
            if (c == "#8a64d6") {
              scoreText.text("NAEP Proficient")
            }
            if (c == "#5c3a92") {
              scoreText.text("NAEP Advanced")
            }
            perfText.text("Reading")
          }
        }
      }

      function circleMouseOut() {
        toolTipScatter.style("visibility", "hidden");

        let st = d3.select(this);

        st.attr("stroke", "")
          .attr("stroke-width", 0)
      }

      updateGraph([], spendExtent)
      updatePerformance([], spendExtent, perfVarMath, perfVarRead)
      updateScatter(spendExtent, perfVarMath, perfVarRead)

      // ----- Button Functionality -----
      let ppcsButton = d3.select("#opPPCS")

      ppcsButton.on("click", function () {
        if (ppcsButton.classed("selectedOption", false)) {
          ppcsButton.classed("selectedOption", true)
          fedButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("ppcs", ppcs)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let fedButton = d3.select("#opFed")

      fedButton.on("click", function () {
        if (fedButton.classed("selectedOption", false)) {
          fedButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_fed", fedRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let stateButton = d3.select("#opState")

      stateButton.on("click", function () {
        if (stateButton.classed("selectedOption", false)) {
          stateButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          fedButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_state", stateRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let localButton = d3.select("#opLocal")

      localButton.on("click", function () {
        if (localButton.classed("selectedOption", false)) {
          localButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          fedButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_local", localRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      // ----- Button Functionality -----
      let g4Button = d3.select("#opG4")

      g4Button.on("click", function () {
        if (g4Button.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", true)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", false)

          perfVarMath = "g4_math"
          perfVarRead = "g4_read"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let g8Button = d3.select("#opG8")

      g8Button.on("click", function () {
        if (g8Button.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", true)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", false)

          perfVarMath = "g8_math"
          perfVarRead = "g8_read"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let satButton = d3.select("#opSAT")

      satButton.on("click", function () {
        if (satButton.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", true)
          actButton.classed("selectedOption", false)

          perfVarMath = "sat_math"
          perfVarRead = "sat_erw"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let actButton = d3.select("#opACT")

      actButton.on("click", function () {
        if (actButton.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", true)

          perfVarMath = "act_math"
          perfVarRead = "act_erw"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })
    }

    requestData()

  </script>


</body>





</html>