<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>


  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .state {
      fill: #e3e3e3;
      cursor: pointer;
    }

    .outline {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      fill: none;
      stroke: #777;
    }

    #stickyHead {
      background-color: #ff9971;
      border: 2px solid black;
      padding: 1%;
      position: sticky;
      position: -webkit-sticky;
      top: 0;
    }

    h1 {
      text-align: center;
      background-color: #ffb79b;
      border: 2px solid black;
      padding: 1%;
    }

    .textBlurb {
      background-color: #fca785;
      border: 2px solid black;
      padding: 1%;
      font-size: larger;
    }

    .row {
      display: flex;
      flex-direction: row;
    }

    .row div {
      width: 50%;
    }

    .row div h3 {
      text-align: center;
    }

    #stateSelect {
      text-align: center;
      margin: 0;
    }

    ul {
      list-style-type: none;
    }

    .options {
      display: flex;
      flex-direction: row;
    }

    .options li {
      width: 25%;
      text-align: center;
      cursor: pointer;
    }

    .selectedOption {
      border: 2px solid black;
      background-color: white;
    }

    .graph-row svg {
      display: block;
      margin: auto;
    }
  </style>

</head>

<body>

  <h1>Does High Academic Performance Rely on High Spending?</h1>

  <p class="textBlurb">
    <strong>Education is the foundation for societal growth and innovation.</strong> Since each state governs how funds
    for education are spent, we want to see if more funding results in higher test scores throughout elementary and
    secondary programs.

    <br>
    <br>

    <em>Select up to 5 states from the map.</em>
  </p>

  <div id="stickyHead">

    <div class="row">
      <div>
        <h3>Spending</h3>

        <ul class="options">
          <li id="opPPCS" class="selectedOption">PPCS</li>
          <li id="opFed">Federal</li>
          <li id="opState">State</li>
          <li id="opLocal">Local</li>
        </ul>

      </div>

      <div>
        <h3>Performance</h3>

        <ul class="options">
          <li id="opG4">NAEP Grade 4</li>
          <li id="opG8">NAEP Grade 8</li>
          <li id="opSAT" class="selectedOption">SAT</li>
          <li id="opACT">ACT</li>
        </ul>

      </div>
    </div>

    <h4 id="stateSelect">States Selected: None</h4>

  </div>

  <!-- <h2 id="mapHeader">Per Pupil Current Spending for Elementary-Secondary (2022)</h2> -->
  <div class="row graph-row">
    <svg id="map1" width="750" height="750"></svg>
    <svg id="spending" height="600" width="600"></svg>
  </div>
  <div class="row graph-row">
    <svg id="math" width="500" height="500"></svg>
    <svg id="read" width="500" height="500"></svg>
  </div>

  <p>
    Something important to note is that not everyone takes the SAT and not everyone takes the ACT. Some states have low
    percentages of seniors taking the SAT, but the scores are higher than other states. The same goes for the ACT.
  </p>

  <svg id="scatter" width="500" height="500"></svg>

  <script>
    // Map of spending
    const svg = d3.select("#map1");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const mapChart = svg.append("g")
      .attr("id", "mapChart")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Bar chart of spending
    const svgSpend = d3.select("#spending");
    const wSpend = svgSpend.attr("width");
    const hSpend = svgSpend.attr("height");
    const marginSpend = { top: 10, right: 10, bottom: 50, left: 50 };
    const spendChartW = wSpend - marginSpend.left - marginSpend.right;
    const spendChartH = hSpend - marginSpend.bottom - marginSpend.top;
    const spendChart = svgSpend.append("g")
      .attr("id", "spendChart")
      .attr("transform", `translate(${marginSpend.left},${marginSpend.top})`);

    // Bar chart of math performance
    const svgMath = d3.select("#math");
    const wMath = svgMath.attr("width");
    const hMath = svgMath.attr("height");
    const marginMath = { top: 10, right: 10, bottom: 50, left: 50 };
    const mathChartW = wMath - marginMath.left - marginMath.right;
    const mathChartH = hMath - marginMath.bottom - marginMath.top;
    const mathChart = svgMath.append("g")
      .attr("id", "mathChart")
      .attr("transform", `translate(${marginMath.left},${marginMath.top})`);

    // Bar chart of english/reading performance
    const svgRead = d3.select("#read");
    const wRead = svgRead.attr("width");
    const hRead = svgRead.attr("height");
    const marginRead = { top: 10, right: 10, bottom: 50, left: 50 };
    const readChartW = wRead - marginRead.left - marginRead.right;
    const readChartH = hRead - marginRead.bottom - marginRead.top;
    const readChart = svgRead.append("g")
      .attr("id", "mathChart")
      .attr("transform", `translate(${marginRead.left},${marginRead.top})`);

    const svgScatter = d3.select("#scatter")
    const wScatter = svgScatter.attr("width")
    const hScatter = svgScatter.attr("height")
    const marginScatter = { top: 10, right: 10, bottom: 50, left: 50 }
    const scatterChartW = wScatter - marginScatter.left - marginScatter.right
    const scatterChartH = hScatter - marginScatter.top - marginScatter.bottom
    const scatterChart = svgScatter.append("g")
      .attr("id", "scatterChart")
      .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`);


    const requestData = async function () {

      // ------------ Setting up US Map ------------
      const us = await d3.json("us-smaller.json");
      console.log(us);

      var states = topojson.feature(us, us.objects.states);
      var statesMesh = topojson.mesh(us, us.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([chartWidth, chartHeight], states);
      var path = d3.geoPath().projection(projection);

      var graticule = d3.geoGraticule10();
      mapChart.append("path").attr("class", "graticule").attr("d", path(graticule))

      mapChart.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path)
        .on('mouseover', mouseEntersState)
        .on('mouseout', mouseLeavesState)
        .on("click", mouseChangeState)

      mapChart.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      // ------------ Per Pupil Spending by State ------------
      // Can't use d3.autotype because it causes errors with the rev vars
      const edSpend = await d3.csv("es_spend_2022.csv");

      // Fixing data types
      edSpend.forEach((d) => {
        let strToInt = ["ppcs", "pp_rev_total", "pp_rev_fed",
          "pp_rev_state", "pp_rev_local"]

        for (let i = 0; i < strToInt.length; i++) {
          d[strToInt[i]] = parseInt(d[strToInt[i]].replace(",", ""));
        }

        let numerics = ["sat_total", "sat_erw", "sat_math", "sat_perc",
          "act_total", "act_math", "act_read", "act_eng", "act_sci", "act_perc",
          "g8_read", "g8_math", "g4_read", "g4_math"]

        for (let i = 0; i < numerics.length; i++) {
          d[numerics[i]] = Number(d[numerics[i]])
        }

        d["act_erw"] = (d["act_eng"] + d["act_read"]) / 2
      })
      console.log(edSpend)

      // Maps state ID (from map) to the state code
      let stateIDcode = {}

      // Maps state name to state code (used for bar graph)
      let stateNameCode = {}

      // Maps state code to index in edSpend (used for bar graph)
      let codeToEdID = {}

      for (let i = 0; i <= 51; i++) {
        // Alphabetically ordered
        stateIDcode[us.objects.states.geometries[i].id] = edSpend[i].code
        us.objects.states.geometries[i].properties = edSpend[i]

        stateNameCode[edSpend[i].state] = edSpend[i].code
        codeToEdID[edSpend[i].code] = i
      }

      let ppcs = {}
      let fedRev = {}
      let stateRev = {}
      let localRev = {}
      let stateNames = {}
      let satPercs = {}
      let actPercs = {}

      edSpend.forEach(d => {
        ppcs[d.code] = d.ppcs;
        fedRev[d.code] = d["pp_rev_fed"];
        stateRev[d.code] = d["pp_rev_state"];
        localRev[d.code] = d["pp_rev_local"];
        stateNames[d.code] = d.state;

        satPercs[d.code] = d["sat_perc"]
        actPercs[d.code] = d["act_perc"]
      });

      // color options
      let greenColors = ["#cce7c9", "#8bca84", "#5bb450", "#46923c", "#276221"]
      let purpleColors = ["#bca0dc", "#b491c8", "#7c5295", "#663a82", "#52307c"]
      let cyanColors = ["#45f7e5", "#3bd1c2", "#33b3a6", "#289086", "#207169"]
      let blueColors = ["#caf0f8", "#90e0ef", "#00b4d8", "#0077b6", "#023e8a"]

      let useColors = greenColors

      let perfVarMath = "sat_math"
      let perfVarRead = "sat_erw"

      function updateMap(spendVar, spendDct) {
        // default => ppcs
        let useColors = greenColors

        if (spendVar == "pp_rev_fed") {
          useColors = purpleColors
        }
        if (spendVar == "pp_rev_state") {
          useColors = cyanColors
        }
        if (spendVar == "pp_rev_local") {
          useColors = blueColors
        }

        const spendExtent = d3.extent(Object.values(spendDct));

        const spendColorScale = d3.scaleQuantile()
          .domain(Object.values(spendDct))
          .range(useColors);

        mapChart.selectAll(".state")
          .data(edSpend)
          .style("fill", d => spendColorScale(spendDct[d.code]))

        // Create color scale legend
        let legendQuantile = mapChart.append("g")
          .attr("class", "legend")

        let scaleW = 50

        for (let i = 0; i < useColors.length; i++) {
          legendQuantile.append("rect")
            .attr("fill", useColors[i])
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .attr("x", chartWidth / 4 + (i * scaleW))
            .attr("y", chartHeight - 100)
            .attr("width", scaleW)
            .attr("height", 25)
        }

        let testExt = [spendExtent[0], spendColorScale.quantiles()[0],
        spendColorScale.quantiles()[1], spendColorScale.quantiles()[2],
        spendColorScale.quantiles()[3], spendExtent[1]]

        const colorLegendScale = d3.scaleOrdinal()
          .domain(testExt)
          .range([0, scaleW, scaleW * 2, scaleW * 3, scaleW * 4, scaleW * 5])

        let bottomAxisColor = d3.axisBottom(colorLegendScale)
          .ticks(4)
          .tickValues(testExt)
          .tickFormat(d3.format("$.2s"))

        legendQuantile.append("g")
          .attr("class", "x axis legRemove")
          .attr("transform",
            `translate(${chartWidth / 4},${chartHeight - 75})`
          )
          .call(bottomAxisColor);

        return [spendExtent, spendColorScale, spendVar]
      }

      let spendValues = updateMap("ppcs", ppcs)
      let spendExtent = spendValues[0]
      let spendColorScale = spendValues[1]
      let spendVar = spendValues[2]

      // Tool Tip
      let toolTipWidth = 150
      let toolTipHeight = 100

      let mouseMesh = mapChart.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "orange")
        .style("stroke-width", 1)
        .attr("d", "")

      let clickMesh = mapChart.append("path")
        .attr("class", "click outline")
        .style("stroke", "yellow")
        .style("stroke-width", 3)
        .attr("d", "")

      let toolTip = mapChart.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      let xPos = width - (toolTipWidth * 1.5) - margin.left - margin.right
      let yPos = toolTipHeight + margin.top

      toolTip.append("rect")
        .attr("fill", "black")
        .attr("opacity", .8)
        .attr("rx", 6)
        .attr("ry", 6)
        .attr("x", xPos)
        .attr("y", yPos)
        .attr("width", toolTipWidth)
        .attr("height", toolTipHeight);

      let stateText = toolTip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", xPos + (toolTipWidth / 2))
        .attr("y", yPos + 5);

      let ppcsText = toolTip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", xPos + (toolTipWidth / 2))
        .attr("y", yPos + 25);

      // Mouse In
      function mouseEntersState() {
        toolTip.style("visibility", "visible");

        let st = d3.select(this);

        var format = d3.format("$,")

        stateText.text(st.datum().state + " (" + st.datum().code + ")")
        ppcsText.text(format(st.datum()[spendVar]))

        var mou = topojson.mesh(us, us.objects.states, function (a, b) {
          return a.id < 72 && a.properties.state === st.datum().state || b.id < 72 && b.properties.state === st.datum().state
        });

        mouseMesh.datum(mou).attr("d", path)
      }

      // Mouse Out
      function mouseLeavesState() {
        toolTip.style("visibility", "hidden");

        let st = d3.select(this)

        mouseMesh.attr("d", "")
      }

      // Highlighting states on click
      let selectedStates = []

      function highlightState(selectedStates) {
        let len = selectedStates.length

        if (len === 1) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
          });
        }
        if (len === 2) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
          });
        }
        if (len === 3) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]

          });
        }
        if (len === 4) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]
              || a.id < 72 && a.properties.state === selectedStates[3] || b.id < 72 && b.properties.state === selectedStates[3]

          });
        }
        if (len === 5) {
          var mou = topojson.mesh(us, us.objects.states, function (a, b) {
            return a.id < 72 && a.properties.state === selectedStates[0] || b.id < 72 && b.properties.state === selectedStates[0]
              || a.id < 72 && a.properties.state === selectedStates[1] || b.id < 72 && b.properties.state === selectedStates[1]
              || a.id < 72 && a.properties.state === selectedStates[2] || b.id < 72 && b.properties.state === selectedStates[2]
              || a.id < 72 && a.properties.state === selectedStates[3] || b.id < 72 && b.properties.state === selectedStates[3]
              || a.id < 72 && a.properties.state === selectedStates[4] || b.id < 72 && b.properties.state === selectedStates[4]
          });
        }

        clickMesh.datum(mou).attr("d", path)
      }

      // Mouse Change
      function mouseChangeState() {
        let st = d3.select(this);

        if (selectedStates.length < 5 && selectedStates.indexOf(st.datum().state) === -1) {
          selectedStates.push(st.datum().state);
          highlightState(selectedStates);
        } else {
          if (selectedStates.length == 5 && selectedStates.indexOf(st.datum().state) === -1) {
            console.log("Too many states selected. Click a selected state to remove.")
          } else {
            selectedStates.splice(selectedStates.indexOf(st.datum().state), 1)
            highlightState(selectedStates);
          }
        }

        const ssHeader = d3.select("#stateSelect");
        if (selectedStates.length == 0) {
          ssHeader.text("States Selected: None")
        } else {
          let acc_str = "States Selected: "
          for (let i = 0; i < selectedStates.length; i++) [
            acc_str = acc_str + selectedStates[i] + ", "
          ]
          acc_str = acc_str.substring(0, acc_str.length - 2)
          ssHeader.text(acc_str)
        }

        d3.selectAll("g.remove").remove()
        d3.selectAll("text.remove").remove()
        updateGraph(selectedStates, spendExtent)

        d3.selectAll("g.removePerf").remove()
        d3.selectAll("text.removePerf").remove()
        updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

      }

      // ------------ All Bar Charts  ------------

      // ------------ Spending Bar Chart ------------

      let spendAnno = svgSpend.append("g").attr("id", "spendAnno");
      let mathAnno = svgMath.append("g").attr("id", "mathAnno");
      let readAnno = svgRead.append("g").attr("id", "readAnno");

      // update spending bar graph depended on states selected
      function updateGraph(selectedStates, spendExtent) {
        // x axis = selected states + us
        let barStates = []
        barStates.push("US")

        // Change state names to state codes
        for (let i = 0; i < selectedStates.length; i++) {
          barStates.push(stateNameCode[selectedStates[i]]);
        }

        let barIDs = []

        for (let i = 0; i < barStates.length; i++) {
          barIDs.push(codeToEdID[barStates[i]])
        }

        let subData = edSpend.filter((d, i) => {
          return barIDs.includes(i)
        });

        let xStateScale = d3.scaleBand()
          .domain(barStates)
          .range([0, wSpend - marginSpend.left]);

        let bottomAxisSpend = d3.axisBottom(xStateScale);

        let ySpendScale = d3.scaleLinear()
          .domain([0, spendExtent[1]])
          .range([spendChartH, 0])

        let leftAxisSpend = d3.axisLeft(ySpendScale).tickFormat(d3.format("$.2s"));

        spendAnno.append("g")
          .attr("class", "y axis remove")
          .attr("transform",
            `translate(${marginSpend.left},${marginSpend.top})`
          )
          .call(leftAxisSpend);

        let leftGridlinesSpend = d3.axisLeft(ySpendScale)
          .tickSize(-wSpend - marginSpend.right)
          .tickFormat("");

        spendAnno.append("g")
          .attr("class", "y gridlines remove")
          .attr("transform",
            `translate(${marginSpend.left},${marginSpend.top})`
          )
          .call(leftGridlinesSpend);

        spendAnno.append("g")
          .attr("class", "x axis remove")
          .attr("transform",
            `translate(${marginSpend.left},${hSpend - marginSpend.bottom})`
          )
          .call(bottomAxisSpend);

        spendAnno.append("text")
          .attr("class", "x-label remove")
          .attr("transform", `translate(${spendChartW / 2 + marginSpend.left}, ${hSpend - marginSpend.bottom + 4 * marginSpend.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let spendYLabel = "Current Spending Per Pupil"

        if (spendVar == "pp_rev_fed") {
          spendYLabel = "Federal Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_state") {
          spendYLabel = "State Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_local") {
          spendYLabel = "Local Revenue Per Pupil"
        }

        spendAnno.append("text")
          .attr("class", "y-label remove")
          .attr("transform", `translate(${marginSpend.right}, ${spendChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(spendYLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        spendAnno.append("text")
          .attr("class", "chart-title remove")
          .attr("transform", `translate(${spendChartH / 2 + marginSpend.left}, ${marginSpend.top})`)
          .style("text-anchor", "middle")
          .text(spendYLabel + " for Elementary-Secondary (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let barW = 20

        spendChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => ySpendScale(d[spendVar]))
          .attr("height", d => spendChartH - ySpendScale(d[spendVar]))
          .attr("width", d => barW)

        spendChart.raise()

      }

      function updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead) {

        let barStates = []
        barStates.push("US")

        // Change state names to state codes
        for (let i = 0; i < selectedStates.length; i++) {
          barStates.push(stateNameCode[selectedStates[i]]);
        }

        let barIDs = []

        for (let i = 0; i < barStates.length; i++) {
          barIDs.push(codeToEdID[barStates[i]])
        }

        let subData = edSpend.filter((d, i) => {
          return barIDs.includes(i)
        });

        let xStateScale = d3.scaleBand()
          .domain(barStates)
          .range([0, wMath - marginMath.left]);

        // default: sat
        let perfExtent = [200, 800]
        let yMathLabel = "SAT Math Scores"
        let yReadLabel = "SAT ERW Scores"

        if (perfVarMath == "act_math") {
          perfExtent = [2, 36]
          yMathLabel = "ACT Math Scores"
          yReadLabel = "ACT Reading + English Scores"
        }
        if (perfVarMath == "g4_math") {
          perfExtent = [0, 500]
          yMathLabel = "NAEP Grade 4 Math Scores"
          yReadLabel = "NAEP Grade 4 Reading Scores"
        }
        if (perfVarMath == "g8_math") {
          perfExtent = [0, 500]
          yMathLabel = "NAEP Grade 8 Math Scores"
          yReadLabel = "NAEP Grade 8 Reading Scores"
        }

        let yMathScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([mathChartH, 0])

        let leftAxisMath = d3.axisLeft(yMathScale)

        mathAnno.append("g")
          .attr("class", "y axis removePerf")
          .attr("transform",
            `translate(${marginMath.left},${marginMath.top})`
          )
          .call(leftAxisMath);

        let leftGridlinesMath = d3.axisLeft(yMathScale)
          .tickSize(-mathChartW - marginMath.right)
          .tickFormat("");

        mathAnno.append("g")
          .attr("class", "y gridlines removePerf")
          .attr("transform",
            `translate(${marginMath.left},${marginMath.top})`
          )
          .call(leftGridlinesMath);

        let bottomAxisMath = d3.axisBottom(xStateScale);

        mathAnno.append("g")
          .attr("class", "x axis removePerf")
          .attr("transform",
            `translate(${marginMath.left},${mathChartH + marginMath.top})`
          )
          .call(bottomAxisMath);

        mathAnno.append("text")
          .attr("class", "x-label removePerf")
          .attr("transform", `translate(${mathChartW / 2 + marginMath.left}, ${hMath - marginMath.bottom + 4 * marginMath.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        mathAnno.append("text")
          .attr("class", "y-label removePerf")
          .attr("transform", `translate(${marginMath.right}, ${mathChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yMathLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        mathAnno.append("text")
          .attr("class", "chart-title removePerf")
          .attr("transform", `translate(${mathChartH / 2 + marginMath.left}, ${marginMath.top})`)
          .style("text-anchor", "middle")
          .text("Average " + yMathLabel + " (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        let barW = 20

        mathChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => yMathScale(d[perfVarMath]))
          .attr("height", d => mathChartH - yMathScale(d[perfVarMath]))
          .attr("width", d => barW)

        mathChart.raise()

        // ---- Reading ----

        let yReadScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([readChartH, 0])

        let leftAxisRead = d3.axisLeft(yReadScale);

        readAnno.append("g")
          .attr("class", "y axis removePerf")
          .attr("transform",
            `translate(${marginRead.left},${marginRead.top})`
          )
          .call(leftAxisRead);

        let leftGridlinesRead = d3.axisLeft(yReadScale)
          .tickSize(-readChartW - marginRead.right)
          .tickFormat("");

        readAnno.append("g")
          .attr("class", "y gridlines removePerf")
          .attr("transform",
            `translate(${marginRead.left},${marginRead.top})`
          )
          .call(leftGridlinesRead);

        let bottomAxisRead = d3.axisBottom(xStateScale);

        readAnno.append("g")
          .attr("class", "x axis removePerf")
          .attr("transform",
            `translate(${marginRead.left},${readChartH + marginRead.top})`
          )
          .call(bottomAxisRead);

        readAnno.append("text")
          .attr("class", "x-label removePerf")
          .attr("transform", `translate(${readChartW / 2 + marginRead.left}, ${hRead - marginRead.bottom + 4 * marginRead.top})`)
          .style("text-anchor", "middle")
          .text("States")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readAnno.append("text")
          .attr("class", "y-label removePerf")
          .attr("transform", `translate(${marginRead.right}, ${readChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yReadLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readAnno.append("text")
          .attr("class", "chart-title removePerf")
          .attr("transform", `translate(${readChartH / 2 + marginRead.left}, ${marginRead.top})`)
          .style("text-anchor", "middle")
          .text("Average " + yReadLabel + " (2022)")
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        readChart.selectAll("rect.pos")
          .data(subData)
          .join("rect")
          .attr("class", "pos")
          .attr("fill", d => spendColorScale(d[spendVar]))
          .attr("x", d => xStateScale(d.code) - (barW / 2) + (xStateScale.bandwidth() / 2))
          .attr("y", d => yReadScale(d[perfVarRead]))
          .attr("height", d => readChartH - yReadScale(d[perfVarRead]))
          .attr("width", d => barW)

        readChart.raise()
      }

      let scatterAnno = svgScatter.append("g").attr("id", "scatterAnno");

      function updateScatter(spendExtent, perfVarMath, perfVarRead) {

        console.log("Scatter Debugging")

        let xSpendScale = d3.scaleLinear()
          .domain(spendExtent)
          .range([0, scatterChartW])

        let perfExtent = [400, 1600]
        let yScatterLabel = "SAT Total Scores"
        let yCol = "sat_total"
        let gradeTest = perfVarMath == "g4_math" || perfVarMath == "g8_math"
        let colorCol = "sat_perc"


        if (perfVarMath == "act_math") {
          perfExtent = [1, 36]
          yScatterLabel = "ACT Composite Scores"
          yCol = "act_total"
          colorCol = "act_perc"
        }
        if (perfVarMath == "g4_math") {
          perfExtent = [175, 325]
          yScatterLabel = "NAEP Grade 4 Scores"
        }
        if (perfVarMath == "g8_math") {
          perfExtent = [175, 325]
          yScatterLabel = "NAEP Grade 8 Scores"
        }

        let colorPercScale = d3.scaleQuantile()
          .domain([0, 100])
          .range(["#eec4dc", "#e27bb1", "#e44b8d", "#bb437e", "#7f3667"]);

        let yPerfScale = d3.scaleLinear()
          .domain(perfExtent)
          .range([scatterChartH, 0])

        let leftAxisScatter = d3.axisLeft(yPerfScale).tickFormat(d3.format("d"))

        scatterAnno.append("g")
          .attr("class", "y axis removeScatter")
          .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`)
          .call(leftAxisScatter)

        let leftGridlinesScatter = d3.axisLeft(yPerfScale)
          .tickSize(-scatterChartW - marginScatter.right)
          .tickFormat("")

        scatterAnno.append("g")
          .attr("class", "y gridlines removeScatter")
          .attr("transform", `translate(${marginScatter.left},${marginScatter.top})`)
          .call(leftGridlinesScatter)

        let bottomAxisScatter = d3.axisBottom(xSpendScale).tickFormat(d3.format("$.2s")).ticks(8);

        scatterAnno.append("g")
          .attr("class", "x axis removeScatter")
          .attr("transform", `translate(${marginScatter.left + marginScatter.right / 2},${scatterChartH + marginScatter.top})`)
          .call(bottomAxisScatter)

        let xSpendLabel = "Per Pupil Current Spending"

        if (spendVar == "pp_rev_fed") {
          xSpendLabel = "Federal Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_state") {
          xSpendLabel = "State Revenue Per Pupil"
        }
        if (spendVar == "pp_rev_local") {
          xSpendLabel = "Local Revenue Per Pupil"
        }

        scatterAnno.append("text")
          .attr("class", "x-label removeScatter")
          .attr("transform",
            `translate(${scatterChartW / 2 + marginScatter.left}, ${hScatter - marginScatter.bottom + 4 * marginScatter.top})`
          )
          .style("text-anchor", "middle")
          .text(xSpendLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        scatterAnno.append("text")
          .attr("class", "y-label removeScatter")
          .attr("transform", `translate(${marginScatter.right}, ${scatterChartH / 2}) rotate(-90)`)
          .style("text-anchor", "middle")
          .text(yScatterLabel)
          .attr("fill", "black")
          .style("font-family", "monospace")
          .style("font-weight", "bold");

        if (!gradeTest) {
          d3.selectAll("circle.p2").remove()

          scatterChart.selectAll("circle.point")
            .data(edSpend)
            .join("circle")
            .attr("class", "point")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[yCol]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => {
              if (gradeTest) { return "blue" }
              else { return colorPercScale(d[colorCol]) }

            })
        } else {
          let mathData = edSpend.filter((d) => {
            return d[perfVarMath] > 0
          });

          let readData = edSpend.filter((d) => {
            return d[perfVarRead] > 0
          });

          scatterChart.selectAll("circle.point")
            .data(mathData)
            .join("circle")
            .attr("class", "point")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[perfVarMath]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => NAEPColor(d[perfVarMath], perfVarMath))

          scatterChart.selectAll("circle.p2")
            .data(readData)
            .join("circle")
            .attr("class", "p2")
            .attr("opacity", 0.75)
            .attr("cx", d => xSpendScale(d[spendVar]) + marginScatter.right / 2)
            .attr("cy", d => yPerfScale(d[perfVarRead]))
            .attr("r", 5)
            .on("mouseover", circleMouseOver)
            .on("mouseout", circleMouseOut)
            .attr("fill", d => NAEPColor(d[perfVarRead], perfVarRead))
        }

        scatterChart.raise()
      }

      function NAEPColor(totalScore, perfVar) {
        // color math and reading differently 
        // color differently based on naep category (basic, proficient, advanced)
        let coolColors = ["#3acadf", "#729efd", "#8a64d6", "#5c3a92"]
        let warmColors = ["#ffc100", "#ff9800", "#ff5607", "#f6412d"]

        // this categorization comes from NAEP
        if (perfVar == "g4_math") {
          if (totalScore < 214) {
            return warmColors[0]
          }
          if (totalScore >= 214 && totalScore < 249) {
            return warmColors[1]
          }
          if (totalScore >= 249 && totalScore < 282) {
            return warmColors[2]
          }
          if (totalScore >= 282) {
            return warmColors[3]
          }
        }
        if (perfVar == "g4_read") {
          if (totalScore < 208) {
            return coolColors[0]
          }
          if (totalScore >= 208 && totalScore < 238) {
            return coolColors[1]
          }
          if (totalScore >= 238 && totalScore < 268) {
            return coolColors[2]
          }
          if (totalScore >= 268) {
            return coolColors[3]
          }
        }
        if (perfVar == "g8_math") {
          if (totalScore < 262) {
            return warmColors[0]
          }
          if (totalScore >= 262 && totalScore < 299) {
            return warmColors[1]
          }
          if (totalScore >= 299 && totalScore < 333) {
            return warmColors[2]
          }
          if (totalScore >= 333) {
            return warmColors[3]
          }
        }
        if (perfVar == "g8_read") {
          if (totalScore < 243) {
            return coolColors[0]
          }
          if (totalScore >= 243 && totalScore < 281) {
            return coolColors[1]
          }
          if (totalScore >= 281 && totalScore < 323) {
            return coolColors[2]
          }
          if (totalScore >= 323) {
            return coolColors[3]
          }
        }
      }

      function circleMouseOver() {
        console.log("Circle hover")
        d3.select(this)
          .attr("stroke", "black")
          .attr("stroke-width", 2)
      }

      function circleMouseOut() {
        d3.select(this)
          .attr("stroke", "")
          .attr("stroke-width", 0)
      }

      updateGraph([], spendExtent)
      updatePerformance([], spendExtent, perfVarMath, perfVarRead)
      updateScatter(spendExtent, perfVarMath, perfVarRead)

      // ----- Button Functionality -----
      let ppcsButton = d3.select("#opPPCS")

      ppcsButton.on("click", function () {
        if (ppcsButton.classed("selectedOption", false)) {
          ppcsButton.classed("selectedOption", true)
          fedButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("ppcs", ppcs)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let fedButton = d3.select("#opFed")

      fedButton.on("click", function () {
        if (fedButton.classed("selectedOption", false)) {
          fedButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_fed", fedRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let stateButton = d3.select("#opState")

      stateButton.on("click", function () {
        if (stateButton.classed("selectedOption", false)) {
          stateButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          fedButton.classed("selectedOption", false)
          localButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_state", stateRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let localButton = d3.select("#opLocal")

      localButton.on("click", function () {
        if (localButton.classed("selectedOption", false)) {
          localButton.classed("selectedOption", true)
          ppcsButton.classed("selectedOption", false)
          fedButton.classed("selectedOption", false)
          stateButton.classed("selectedOption", false)
          d3.selectAll("g.legRemove").remove()
          d3.selectAll("text.legRemove").remove()

          spendValues = updateMap("pp_rev_local", localRev)
          spendExtent = spendValues[0]
          spendColorScale = spendValues[1]
          spendVar = spendValues[2]
          d3.selectAll("g.remove").remove()
          d3.selectAll("text.remove").remove()
          updateGraph(selectedStates, spendExtent)
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      // ----- Button Functionality -----
      let g4Button = d3.select("#opG4")

      g4Button.on("click", function () {
        if (g4Button.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", true)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", false)

          perfVarMath = "g4_math"
          perfVarRead = "g4_read"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let g8Button = d3.select("#opG8")

      g8Button.on("click", function () {
        if (g8Button.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", true)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", false)

          perfVarMath = "g8_math"
          perfVarRead = "g8_read"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let satButton = d3.select("#opSAT")

      satButton.on("click", function () {
        if (satButton.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", true)
          actButton.classed("selectedOption", false)

          perfVarMath = "sat_math"
          perfVarRead = "sat_erw"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })

      let actButton = d3.select("#opACT")

      actButton.on("click", function () {
        if (actButton.classed("selectedOption", false)) {
          g4Button.classed("selectedOption", false)
          g8Button.classed("selectedOption", false)
          satButton.classed("selectedOption", false)
          actButton.classed("selectedOption", true)

          perfVarMath = "act_math"
          perfVarRead = "act_erw"

          d3.selectAll("g.removePerf").remove()
          d3.selectAll("text.removePerf").remove()
          updatePerformance(selectedStates, spendExtent, perfVarMath, perfVarRead)

          d3.selectAll("g.removeScatter").remove()
          d3.selectAll("text.removeScatter").remove()
          updateScatter(spendExtent, perfVarMath, perfVarRead)
        }
      })
    }

    requestData()

  </script>


</body>





</html>